<?php

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

// Try to load our extension if it's not already loaded.
if (!extension_loaded('ge')) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_ge.dll')) return;
  } else {
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('ge.so')) return;
    } else {
      if (!dl('ge.'.PHP_SHLIB_SUFFIX)) return;
    }
  }
}



/* PHP Proxy Classes */
class DoubleVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_double_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_DoubleVector(); break;
		default: $this->_cPtr=new_DoubleVector($n);
		}
	}

	function size() {
		return DoubleVector_size($this->_cPtr);
	}

	function capacity() {
		return DoubleVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		DoubleVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		DoubleVector_clear($this->_cPtr);
	}

	function push($x) {
		DoubleVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return DoubleVector_is_empty($this->_cPtr);
	}

	function pop() {
		return DoubleVector_pop($this->_cPtr);
	}

	function get($i) {
		return DoubleVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		DoubleVector_set($this->_cPtr,$i,$val);
	}
}

class DoubleDoubleVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_std__vectorT_double_t_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_DoubleDoubleVector(); break;
		default: $this->_cPtr=new_DoubleDoubleVector($n);
		}
	}

	function size() {
		return DoubleDoubleVector_size($this->_cPtr);
	}

	function capacity() {
		return DoubleDoubleVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		DoubleDoubleVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		DoubleDoubleVector_clear($this->_cPtr);
	}

	function push($x) {
		DoubleDoubleVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return DoubleDoubleVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=DoubleDoubleVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function get($i) {
		$r=DoubleDoubleVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function set($i,$val) {
		DoubleDoubleVector_set($this->_cPtr,$i,$val);
	}
}

class FloatVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_float_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_FloatVector(); break;
		default: $this->_cPtr=new_FloatVector($n);
		}
	}

	function size() {
		return FloatVector_size($this->_cPtr);
	}

	function capacity() {
		return FloatVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		FloatVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		FloatVector_clear($this->_cPtr);
	}

	function push($x) {
		FloatVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return FloatVector_is_empty($this->_cPtr);
	}

	function pop() {
		return FloatVector_pop($this->_cPtr);
	}

	function get($i) {
		return FloatVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		FloatVector_set($this->_cPtr,$i,$val);
	}
}

class IntVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_int_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_IntVector(); break;
		default: $this->_cPtr=new_IntVector($n);
		}
	}

	function size() {
		return IntVector_size($this->_cPtr);
	}

	function capacity() {
		return IntVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		IntVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		IntVector_clear($this->_cPtr);
	}

	function push($x) {
		IntVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return IntVector_is_empty($this->_cPtr);
	}

	function pop() {
		return IntVector_pop($this->_cPtr);
	}

	function get($i) {
		return IntVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		IntVector_set($this->_cPtr,$i,$val);
	}
}

class StringVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_std__string_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StringVector(); break;
		default: $this->_cPtr=new_StringVector($n);
		}
	}

	function size() {
		return StringVector_size($this->_cPtr);
	}

	function capacity() {
		return StringVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StringVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StringVector_clear($this->_cPtr);
	}

	function push($x) {
		StringVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StringVector_is_empty($this->_cPtr);
	}

	function pop() {
		return StringVector_pop($this->_cPtr);
	}

	function get($i) {
		return StringVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		StringVector_set($this->_cPtr,$i,$val);
	}
}

class StringStringVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_std__vectorT_std__string_t_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StringStringVector(); break;
		default: $this->_cPtr=new_StringStringVector($n);
		}
	}

	function size() {
		return StringStringVector_size($this->_cPtr);
	}

	function capacity() {
		return StringStringVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StringStringVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StringStringVector_clear($this->_cPtr);
	}

	function push($x) {
		StringStringVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StringStringVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=StringStringVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StringVector($r);
		}
		return $r;
	}

	function get($i) {
		$r=StringStringVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StringVector($r);
		}
		return $r;
	}

	function set($i,$val) {
		StringStringVector_set($this->_cPtr,$i,$val);
	}
}

class GAUSS implements ArrayAccess {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($arg1=null,$isEnvVar=true) {
		if (is_resource($arg1) && get_resource_type($arg1) === '_p_GAUSS') {
			$this->_cPtr=$arg1;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_GAUSS(); break;
		default: $this->_cPtr=new_GAUSS($arg1,$isEnvVar);
		}
	}

	function initialize() {
		return GAUSS_initialize($this->_cPtr);
	}

	function shutdown() {
		GAUSS_shutdown($this->_cPtr);
	}

	function setHome($path) {
		return GAUSS_setHome($this->_cPtr,$path);
	}

	function setHomeVar($environment) {
		return GAUSS_setHomeVar($this->_cPtr,$environment);
	}

	function getHome() {
		return GAUSS_getHome($this->_cPtr);
	}

	function getHomeVar() {
		return GAUSS_getHomeVar($this->_cPtr);
	}

	function getLogFile() {
		return GAUSS_getLogFile($this->_cPtr);
	}

	function setLogFile($filename,$mode) {
		return GAUSS_setLogFile($this->_cPtr,$filename,$mode);
	}

	function getLastErrorText() {
		return GAUSS_getLastErrorText($this->_cPtr);
	}

	function getErrorText($arg1) {
		return GAUSS_getErrorText($this->_cPtr,$arg1);
	}

	function getError() {
		return GAUSS_getError($this->_cPtr);
	}

	function setError($arg1) {
		GAUSS_setError($this->_cPtr,$arg1);
	}

	function createWorkspace($name) {
		$r=GAUSS_createWorkspace($this->_cPtr,$name);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function destroyWorkspace($workspace) {
		return GAUSS_destroyWorkspace($this->_cPtr,$workspace);
	}

	function destroyAllWorkspaces() {
		GAUSS_destroyAllWorkspaces($this->_cPtr);
	}

	function getWorkspace($name) {
		$r=GAUSS_getWorkspace($this->_cPtr,$name);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function getActiveWorkspace() {
		$r=GAUSS_getActiveWorkspace($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function setActiveWorkspace($workspace) {
		return GAUSS_setActiveWorkspace($this->_cPtr,$workspace);
	}

	function loadWorkspace($filename) {
		$r=GAUSS_loadWorkspace($this->_cPtr,$filename);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function getWorkspaceName($workspace) {
		return GAUSS_getWorkspaceName($this->_cPtr,$workspace);
	}

	function updateWorkspaceName($workspace) {
		GAUSS_updateWorkspaceName($this->_cPtr,$workspace);
	}

	function saveWorkspace($workspace,$filename) {
		return GAUSS_saveWorkspace($this->_cPtr,$workspace,$filename);
	}

	function saveProgram($programHandle,$filename) {
		return GAUSS_saveProgram($this->_cPtr,$programHandle,$filename);
	}

	function translateDataloopFile($filename) {
		return GAUSS_translateDataloopFile($this->_cPtr,$filename);
	}

	function executeString($code,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_executeString($this->_cPtr,$code); break;
		default: $r=GAUSS_executeString($this->_cPtr,$code,$workspace);
		}
		return $r;
	}

	function executeFile($filename,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_executeFile($this->_cPtr,$filename); break;
		default: $r=GAUSS_executeFile($this->_cPtr,$filename,$workspace);
		}
		return $r;
	}

	function executeCompiledFile($filename,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_executeCompiledFile($this->_cPtr,$filename); break;
		default: $r=GAUSS_executeCompiledFile($this->_cPtr,$filename,$workspace);
		}
		return $r;
	}

	function compileString($code,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_compileString($this->_cPtr,$code); break;
		default: $r=GAUSS_compileString($this->_cPtr,$code,$workspace);
		}
		return $r;
	}

	function compileFile($filename,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_compileFile($this->_cPtr,$filename); break;
		default: $r=GAUSS_compileFile($this->_cPtr,$filename,$workspace);
		}
		return $r;
	}

	function loadCompiledFile($filename,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_loadCompiledFile($this->_cPtr,$filename); break;
		default: $r=GAUSS_loadCompiledFile($this->_cPtr,$filename,$workspace);
		}
		return $r;
	}

	function executeProgram($programHandle) {
		return GAUSS_executeProgram($this->_cPtr,$programHandle);
	}

	function freeProgram($programHandle) {
		GAUSS_freeProgram($this->_cPtr,$programHandle);
	}

	function makePathAbsolute($path) {
		return GAUSS_makePathAbsolute($this->_cPtr,$path);
	}

	function programInputString() {
		return GAUSS_programInputString($this->_cPtr);
	}

	function getSymbolType($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getSymbolType($this->_cPtr,$name); break;
		default: $r=GAUSS_getSymbolType($this->_cPtr,$name,$workspace);
		}
		return $r;
	}

	function getScalar($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getScalar($this->_cPtr,$name); break;
		default: $r=GAUSS_getScalar($this->_cPtr,$name,$workspace);
		}
		return $r;
	}

	function getMatrix($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getMatrix($this->_cPtr,$name); break;
		default: $r=GAUSS_getMatrix($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new GEMatrix($r);
	}

	function getMatrixAndClear($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getMatrixAndClear($this->_cPtr,$name); break;
		default: $r=GAUSS_getMatrixAndClear($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new GEMatrix($r);
	}

	function getArray($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getArray($this->_cPtr,$name); break;
		default: $r=GAUSS_getArray($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new GEArray($r);
	}

	function getArrayAndClear($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getArrayAndClear($this->_cPtr,$name); break;
		default: $r=GAUSS_getArrayAndClear($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new GEArray($r);
	}

	function getString($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getString($this->_cPtr,$name); break;
		default: $r=GAUSS_getString($this->_cPtr,$name,$workspace);
		}
		return $r;
	}

	function getStringArray($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getStringArray($this->_cPtr,$name); break;
		default: $r=GAUSS_getStringArray($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new GEStringArray($r);
	}

	function setSymbol($arg1,$name,$workspace=null) {
		switch (func_num_args()) {
		case 2: $r=GAUSS_setSymbol($this->_cPtr,$arg1,$name); break;
		default: $r=GAUSS_setSymbol($this->_cPtr,$arg1,$name,$workspace);
		}
		return $r;
	}

	function moveSymbol($symbol,$name,$workspace=null) {
		switch (func_num_args()) {
		case 2: $r=GAUSS_moveSymbol($this->_cPtr,$symbol,$name); break;
		default: $r=GAUSS_moveSymbol($this->_cPtr,$symbol,$name,$workspace);
		}
		return $r;
	}

	function moveMatrix($data,$rows,$cols,$complex,$name,$workspace=null) {
		switch (func_num_args()) {
		case 5: $r=GAUSS_moveMatrix($this->_cPtr,$data,$rows,$cols,$complex,$name); break;
		default: $r=GAUSS_moveMatrix($this->_cPtr,$data,$rows,$cols,$complex,$name,$workspace);
		}
		return $r;
	}

	function getMatrixDirect($name,$workspace=null) {
		switch (func_num_args()) {
		case 1: $r=GAUSS_getMatrixDirect($this->_cPtr,$name); break;
		default: $r=GAUSS_getMatrixDirect($this->_cPtr,$name,$workspace);
		}
		if (!is_resource($r)) return $r;
		return new doubleArray($r);
	}

	function _setSymbol($data_or_symbol,$name,$workspace=null) {
		switch (func_num_args()) {
		case 2: $r=GAUSS__setSymbol($this->_cPtr,$data_or_symbol,$name); break;
		default: $r=GAUSS__setSymbol($this->_cPtr,$data_or_symbol,$name,$workspace);
		}
		return $r;
	}

	function getSymbol($name,$workspace=null) {
		if (!is_resource($r)) return $r;
		return new GESymbol($r);
	}

	static function isMissingValue($arg1) {
		return GAUSS_isMissingValue($arg1);
	}

	static function internalHookOutput($output) {
		GAUSS_internalHookOutput($output);
	}

	static function internalHookError($output) {
		GAUSS_internalHookError($output);
	}

	static function internalHookFlush() {
		GAUSS_internalHookFlush();
	}

	static function internalHookInputString($buf,$len) {
		return GAUSS_internalHookInputString($buf,$len);
	}

	static function internalHookInputChar() {
		return GAUSS_internalHookInputChar();
	}

	static function internalHookInputBlockingChar() {
		return GAUSS_internalHookInputBlockingChar();
	}

	static function internalHookInputCheck() {
		return GAUSS_internalHookInputCheck();
	}

	function getOutput() {
		return GAUSS_getOutput($this->_cPtr);
	}

	function clearOutput() {
		GAUSS_clearOutput($this->_cPtr);
	}

	function getErrorOutput() {
		return GAUSS_getErrorOutput($this->_cPtr);
	}

	function clearErrorOutput() {
		GAUSS_clearErrorOutput($this->_cPtr);
	}

	static function setOutputModeManaged($managed) {
		GAUSS_setOutputModeManaged($managed);
	}

	static function outputModeManaged() {
		return GAUSS_outputModeManaged();
	}

	static function setProgramOutputAll($func) {
		GAUSS_setProgramOutputAll($func);
	}

	static function setProgramOutput($func) {
		GAUSS_setProgramOutput($func);
	}

	static function setProgramErrorOutput($func) {
		GAUSS_setProgramErrorOutput($func);
	}

	static function setProgramFlushOutput($func) {
		GAUSS_setProgramFlushOutput($func);
	}

	static function setProgramInputString($func) {
		GAUSS_setProgramInputString($func);
	}

	static function setProgramInputChar($func) {
		GAUSS_setProgramInputChar($func);
	}

	static function setProgramInputCharBlocking($func) {
		GAUSS_setProgramInputCharBlocking($func);
	}

	static function setProgramInputCheck($func) {
		GAUSS_setProgramInputCheck($func);
	}

	function offsetGet($name) {
		$r=GAUSS_offsetGet($this->_cPtr,$name);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GESymbol($r);
		}
		return $r;
	}

	function offsetSet($name,$v) {
		GAUSS_offsetSet($this->_cPtr,$name,$v);
	}

	function offsetExists($name) {
		return GAUSS_offsetExists($this->_cPtr,$name);
	}

	function offsetUnset($name) {
		GAUSS_offsetUnset($this->_cPtr,$name);
	}
}

class doubleArray implements ArrayAccess, Countable, Iterator {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'position_') return doubleArray_position__set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'position_') return doubleArray_position__get($this->_cPtr);
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if (function_exists('doubleArray_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($nelements_or_data,$nelements=null) {
		if (is_resource($nelements_or_data) && get_resource_type($nelements_or_data) === '_p_doubleArray') {
			$this->_cPtr=$nelements_or_data;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_doubleArray($nelements_or_data); break;
		default: $this->_cPtr=new_doubleArray($nelements_or_data,$nelements);
		}
	}

	function offsetGet($index) {
		return doubleArray_offsetGet($this->_cPtr,$index);
	}

	function offsetSet($index,$value) {
		doubleArray_offsetSet($this->_cPtr,$index,$value);
	}

	function data() {
		return doubleArray_data($this->_cPtr);
	}

	function count() {
		return doubleArray_count($this->_cPtr);
	}

	function reset() {
		return doubleArray_reset($this->_cPtr);
	}

	function offsetExists($offset) {
		return doubleArray_offsetExists($this->_cPtr,$offset);
	}

	function offsetUnset($offset) {
		doubleArray_offsetUnset($this->_cPtr,$offset);
	}

	function rewind() {
		doubleArray_rewind($this->_cPtr);
	}

	function current() {
		return doubleArray_current($this->_cPtr);
	}

	function key() {
		return doubleArray_key($this->_cPtr);
	}

	function next() {
		doubleArray_next($this->_cPtr);
	}

	function valid() {
		return doubleArray_valid($this->_cPtr);
	}
}

class GESymbol {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	function getRows() {
		return GESymbol_getRows($this->_cPtr);
	}

	function getCols() {
		return GESymbol_getCols($this->_cPtr);
	}

	function isComplex() {
		return GESymbol_isComplex($this->_cPtr);
	}

	function size() {
		return GESymbol_size($this->_cPtr);
	}

	function clear() {
		GESymbol_clear($this->_cPtr);
	}

	function toString() {
		return GESymbol_toString($this->_cPtr);
	}

	function type() {
		return GESymbol_type($this->_cPtr);
	}

	function __toString() {
		return GESymbol___toString($this->_cPtr);
	}
}

class GEArray extends GESymbol {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		GESymbol::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return GESymbol::__get($var);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return GESymbol::__isset($var);
	}

	function __construct($orders=null,$data_or_orders_len=null,$complex_or_data=null,$data_len=null,$complex=null) {
		if (is_resource($orders) && get_resource_type($orders) === '_p_GEArray') {
			$this->_cPtr=$orders;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_GEArray(); break;
		case 1: $this->_cPtr=new_GEArray($orders); break;
		case 2: $this->_cPtr=new_GEArray($orders,$data_or_orders_len); break;
		case 3: $this->_cPtr=new_GEArray($orders,$data_or_orders_len,$complex_or_data); break;
		case 4: $this->_cPtr=new_GEArray($orders,$data_or_orders_len,$complex_or_data,$data_len); break;
		default: $this->_cPtr=new_GEArray($orders,$data_or_orders_len,$complex_or_data,$data_len,$complex);
		}
	}

	function getPlane($orders,$imag=false) {
		$r=GEArray_getPlane($this->_cPtr,$orders,$imag);
		if (!is_resource($r)) return $r;
		return new GEMatrix($r);
	}

	function getVector($orders,$imag=false) {
		$r=GEArray_getVector($this->_cPtr,$orders,$imag);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function getElement($orders,$imag=false) {
		return GEArray_getElement($this->_cPtr,$orders,$imag);
	}

	function setElement($arg1,$orders,$imag=false) {
		return GEArray_setElement($this->_cPtr,$arg1,$orders,$imag);
	}

	function getData($imag=false) {
		$r=GEArray_getData($this->_cPtr,$imag);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function getImagData() {
		$r=GEArray_getImagData($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function getOrders() {
		$r=GEArray_getOrders($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new IntVector($r);
		}
		return $r;
	}

	function getDimensions() {
		return GEArray_getDimensions($this->_cPtr);
	}

	function size() {
		return GEArray_size($this->_cPtr);
	}

	function toString() {
		return GEArray_toString($this->_cPtr);
	}

	function clear() {
		GEArray_clear($this->_cPtr);
	}
}

class GEMatrix extends GESymbol implements ArrayAccess, Countable, Iterator {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'position_') return GEMatrix_position__set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		GESymbol::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'position_') return GEMatrix_position__get($this->_cPtr);
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return GESymbol::__get($var);
	}

	function __isset($var) {
		if (function_exists('GEMatrix_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return GESymbol::__isset($var);
	}

	function __construct($data=null,$rows_or_imag_data=null,$cols_or_rows=null,$complex_or_cols=null) {
		if (is_resource($data) && get_resource_type($data) === '_p_GEMatrix') {
			$this->_cPtr=$data;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_GEMatrix(); break;
		case 1: $this->_cPtr=new_GEMatrix($data); break;
		case 2: $this->_cPtr=new_GEMatrix($data,$rows_or_imag_data); break;
		case 3: $this->_cPtr=new_GEMatrix($data,$rows_or_imag_data,$cols_or_rows); break;
		default: $this->_cPtr=new_GEMatrix($data,$rows_or_imag_data,$cols_or_rows,$complex_or_cols);
		}
	}

	function setElement($value,$imag_or_idx_or_row=null,$imag_or_col=null,$imag=null) {
		switch (func_num_args()) {
		case 1: $r=GEMatrix_setElement($this->_cPtr,$value); break;
		case 2: $r=GEMatrix_setElement($this->_cPtr,$value,$imag_or_idx_or_row); break;
		case 3: $r=GEMatrix_setElement($this->_cPtr,$value,$imag_or_idx_or_row,$imag_or_col); break;
		default: $r=GEMatrix_setElement($this->_cPtr,$value,$imag_or_idx_or_row,$imag_or_col,$imag);
		}
		return $r;
	}

	function getElement($imag_or_idx_or_row=null,$imag_or_col=null,$imag=null) {
		switch (func_num_args()) {
		case 0: $r=GEMatrix_getElement($this->_cPtr); break;
		case 1: $r=GEMatrix_getElement($this->_cPtr,$imag_or_idx_or_row); break;
		case 2: $r=GEMatrix_getElement($this->_cPtr,$imag_or_idx_or_row,$imag_or_col); break;
		default: $r=GEMatrix_getElement($this->_cPtr,$imag_or_idx_or_row,$imag_or_col,$imag);
		}
		return $r;
	}

	function getData($imag=false) {
		$r=GEMatrix_getData($this->_cPtr,$imag);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function getImagData() {
		$r=GEMatrix_getImagData($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new DoubleVector($r);
		}
		return $r;
	}

	function clear() {
		GEMatrix_clear($this->_cPtr);
	}

	function toString() {
		return GEMatrix_toString($this->_cPtr);
	}

	function offsetSet($offset,$value) {
		GEMatrix_offsetSet($this->_cPtr,$offset,$value);
	}

	function offsetExists($offset) {
		return GEMatrix_offsetExists($this->_cPtr,$offset);
	}

	function offsetUnset($offset) {
		GEMatrix_offsetUnset($this->_cPtr,$offset);
	}

	function offsetGet($offset) {
		return GEMatrix_offsetGet($this->_cPtr,$offset);
	}

	function count() {
		return GEMatrix_count($this->_cPtr);
	}

	function rewind() {
		GEMatrix_rewind($this->_cPtr);
	}

	function current() {
		return GEMatrix_current($this->_cPtr);
	}

	function key() {
		return GEMatrix_key($this->_cPtr);
	}

	function next() {
		GEMatrix_next($this->_cPtr);
	}

	function valid() {
		return GEMatrix_valid($this->_cPtr);
	}
}

class GEStringArray extends GESymbol implements ArrayAccess, Countable, Iterator {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'position_') return GEStringArray_position__set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		GESymbol::__set($var,$value);
	}

	function __get($var) {
		if ($var === 'position_') return GEStringArray_position__get($this->_cPtr);
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return GESymbol::__get($var);
	}

	function __isset($var) {
		if (function_exists('GEStringArray_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return GESymbol::__isset($var);
	}

	function __construct($data=null,$rows=null,$cols=null) {
		if (is_resource($data) && get_resource_type($data) === '_p_GEStringArray') {
			$this->_cPtr=$data;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_GEStringArray(); break;
		case 1: $this->_cPtr=new_GEStringArray($data); break;
		case 2: $this->_cPtr=new_GEStringArray($data,$rows); break;
		default: $this->_cPtr=new_GEStringArray($data,$rows,$cols);
		}
	}

	function setData($data,$arg2,$arg3) {
		GEStringArray_setData($this->_cPtr,$data,$arg2,$arg3);
	}

	function setElement($value,$index_or_row,$col=null) {
		switch (func_num_args()) {
		case 2: $r=GEStringArray_setElement($this->_cPtr,$value,$index_or_row); break;
		default: $r=GEStringArray_setElement($this->_cPtr,$value,$index_or_row,$col);
		}
		return $r;
	}

	function getElement($index_or_row,$col=null) {
		switch (func_num_args()) {
		case 1: $r=GEStringArray_getElement($this->_cPtr,$index_or_row); break;
		default: $r=GEStringArray_getElement($this->_cPtr,$index_or_row,$col);
		}
		return $r;
	}

	function getData() {
		$r=GEStringArray_getData($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StringVector($r);
		}
		return $r;
	}

	function toString() {
		return GEStringArray_toString($this->_cPtr);
	}

	function size() {
		return GEStringArray_size($this->_cPtr);
	}

	function clear() {
		GEStringArray_clear($this->_cPtr);
	}

	function offsetSet($offset,$value) {
		GEStringArray_offsetSet($this->_cPtr,$offset,$value);
	}

	function offsetExists($offset) {
		return GEStringArray_offsetExists($this->_cPtr,$offset);
	}

	function offsetUnset($offset) {
		GEStringArray_offsetUnset($this->_cPtr,$offset);
	}

	function offsetGet($offset) {
		return GEStringArray_offsetGet($this->_cPtr,$offset);
	}

	function count() {
		return GEStringArray_count($this->_cPtr);
	}

	function rewind() {
		GEStringArray_rewind($this->_cPtr);
	}

	function current() {
		return GEStringArray_current($this->_cPtr);
	}

	function key() {
		return GEStringArray_key($this->_cPtr);
	}

	function next() {
		GEStringArray_next($this->_cPtr);
	}

	function valid() {
		return GEStringArray_valid($this->_cPtr);
	}
}

class GEWorkspace {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($arg1,$arg2=null) {
		if (is_resource($arg1) && get_resource_type($arg1) === '_p_GEWorkspace') {
			$this->_cPtr=$arg1;
			return;
		}
		switch (func_num_args()) {
		case 1: $this->_cPtr=new_GEWorkspace($arg1); break;
		default: $this->_cPtr=new_GEWorkspace($arg1,$arg2);
		}
	}

	function setName($arg1) {
		GEWorkspace_setName($this->_cPtr,$arg1);
	}

	function name() {
		return GEWorkspace_name($this->_cPtr);
	}

	function setWorkspace($arg1) {
		GEWorkspace_setWorkspace($this->_cPtr,$arg1);
	}

	function workspace() {
		return GEWorkspace_workspace($this->_cPtr);
	}

	function clear() {
		GEWorkspace_clear($this->_cPtr);
	}
}

class WorkspaceManager {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_WorkspaceManager') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_WorkspaceManager();
	}

	function getCurrent() {
		$r=WorkspaceManager_getCurrent($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function setCurrent($wh) {
		return WorkspaceManager_setCurrent($this->_cPtr,$wh);
	}

	function getWorkspace($arg1) {
		$r=WorkspaceManager_getWorkspace($this->_cPtr,$arg1);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function destroyAll() {
		WorkspaceManager_destroyAll($this->_cPtr);
	}

	function destroy($arg1) {
		return WorkspaceManager_destroy($this->_cPtr,$arg1);
	}

	function create($arg1) {
		$r=WorkspaceManager_create($this->_cPtr,$arg1);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new GEWorkspace($r);
		}
		return $r;
	}

	function workspaceNames() {
		$r=WorkspaceManager_workspaceNames($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StringVector($r);
		}
		return $r;
	}

	function count() {
		return WorkspaceManager_count($this->_cPtr);
	}

	function contains($arg1) {
		return WorkspaceManager_contains($this->_cPtr,$arg1);
	}

	function isValidWorkspace($arg1) {
		return WorkspaceManager_isValidWorkspace($this->_cPtr,$arg1);
	}
}

abstract class IGEProgramOutput {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function invoke($message) {
		IGEProgramOutput_invoke($this->_cPtr,$message);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_IGEProgramOutput') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'IGEProgramOutput') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_IGEProgramOutput($_this);
	}
}

abstract class IGEProgramFlushOutput {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function invoke() {
		IGEProgramFlushOutput_invoke($this->_cPtr);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_IGEProgramFlushOutput') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'IGEProgramFlushOutput') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_IGEProgramFlushOutput($_this);
	}
}

abstract class IGEProgramInputString {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function invoke($length) {
		IGEProgramInputString_invoke($this->_cPtr,$length);
	}

	function setValue($value) {
		IGEProgramInputString_setValue($this->_cPtr,$value);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_IGEProgramInputString') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'IGEProgramInputString') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_IGEProgramInputString($_this);
	}
}

abstract class IGEProgramInputChar {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function invoke() {
		return IGEProgramInputChar_invoke($this->_cPtr);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_IGEProgramInputChar') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'IGEProgramInputChar') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_IGEProgramInputChar($_this);
	}
}

abstract class IGEProgramInputCheck {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function invoke() {
		return IGEProgramInputCheck_invoke($this->_cPtr);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_IGEProgramInputCheck') {
			$this->_cPtr=$res;
			return;
		}
		if (get_class($this) === 'IGEProgramInputCheck') {
			$_this = null;
		} else {
			$_this = $this;
		}
		$this->_cPtr=new_IGEProgramInputCheck($_this);
	}
}

class GESymType {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_ge_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __get($var) {
		if ($var === 'thisown') return swig_ge_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	const SCALAR = GESymType_SCALAR;

	const SPARSE = GESymType_SPARSE;

	const MATRIX = GESymType_MATRIX;

	const STRING = GESymType_STRING;

	const STRUCT = GESymType_STRUCT;

	const PSTRUCT = GESymType_PSTRUCT;

	const STRING_ARRAY = GESymType_STRING_ARRAY;

	const ARRAY_GAUSS = GESymType_ARRAY_GAUSS;

	const PROC = GESymType_PROC;

	const OTHER = GESymType_OTHER;

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_GESymType_s') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_GESymType();
	}
}


?>
